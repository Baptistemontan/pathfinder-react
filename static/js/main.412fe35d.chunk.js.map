{"version":3,"sources":["components/Node.jsx","components/List.jsx","components/Grid.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","onMouseDown","e","parent","launchID","autoRefresh","reset","button","weightToggle","mousePressed","node","isStart","isEnd","moveStart","moveEnd","weight","removeWeights","addWeights","isWall","removeWalls","addWalls","onMouseEnter","setState","exNodeRow","startNode","row","exNodeCol","col","grid","updateIO","endNode","launch","onUpdate","isPath","isVisited","onVisitedUpdate","onPathUpdate","onReset","isChecked","onIOUpdate","state","eventName","this","document","addEventListener","classNames","className","Component","List","handleListClick","active","handleOptionClick","content","name","handleChange","choices","question","id","optionsContainerClass","onClick","map","index","key","type","htmlFor","sendEvent","event","CustomEvent","dispatchEvent","Grid","initGrid","createNode","update","Math","random","forEach","clear","visualizeButtonHandler","animation","activeAlgo","distance","algos","Dijkstra","element","getElementById","classList","add","setTimeout","remove","handleMouseUp","handleAlgoChange","handleRefreshChange","handleSpeedChange","speed","handleMazeGeneration","mazeGenerator","undefined","diagonal","speeds","refresh","preventDefault","onMouseUp","parentNode","goalRow","goalCol","astar","ID","nodeQueue","iteration","vectors","push","sortQueue","sort","a","b","comparaison","heuristic","testNeighbour","neighbourNode","abs","updateVisited","pathFounded","offset","updatePath","vector","nextNode","shift","availablesNeigbours","testNeigbours","length","randomNeighbour","floor","openMiddleNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"+RAKqBA,E,YACnB,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KAuBRC,YAAc,SAAAC,GACZ,EAAKC,OAAOC,SAAW,KAClB,EAAKD,OAAOE,aACf,EAAKF,OAAOG,QAIG,IAAbJ,EAAEK,SACJ,EAAKJ,OAAOK,cAAe,GAE7B,EAAKL,OAAOM,cAAe,EACvB,EAAKC,KAAKC,SAAW,EAAKD,KAAKE,MAC7B,EAAKF,KAAKC,QACZ,EAAKR,OAAOU,WAAY,EAExB,EAAKV,OAAOW,SAAU,EAGpB,EAAKX,OAAOK,aACV,EAAKE,KAAKK,OAAS,EACrB,EAAKZ,OAAOa,eAAgB,EAE5B,EAAKb,OAAOc,YAAa,EAGvB,EAAKP,KAAKQ,OACZ,EAAKf,OAAOgB,aAAc,EAE1B,EAAKhB,OAAOiB,UAAW,EAM7B,EAAKC,gBA1DY,EA6DnBA,aAAe,WACb,GAAI,EAAKlB,OAAOM,aACd,IAAK,EAAKN,OAAOU,YAAa,EAAKV,OAAOW,SAAa,EAAKJ,KAAKQ,OA0B7D,EAAKf,OAAOiB,WACX,EAAKV,KAAKQ,QACU,IAArB,EAAKR,KAAKK,QAEV,EAAKL,KAAKQ,QAAS,EACnB,EAAKI,SAAS,CAAEJ,QAAQ,KACf,EAAKf,OAAOgB,aAAe,EAAKT,KAAKQ,QAC9C,EAAKR,KAAKQ,QAAS,EACnB,EAAKI,SAAS,CAAEJ,QAAQ,KAExB,EAAKf,OAAOc,YACS,IAArB,EAAKP,KAAKK,SACT,EAAKL,KAAKQ,QAEX,EAAKR,KAAKK,OA1GL,GA2GL,EAAKO,SAAS,CAAEP,OA3GX,MA4GI,EAAKZ,OAAOa,eAAiB,EAAKN,KAAKK,OAAS,IACzD,EAAKL,KAAKK,OAAS,EACnB,EAAKO,SAAS,CAAEP,OAAQ,SA5C6C,CAEvE,GAAI,EAAKZ,OAAOU,YAAc,EAAKH,KAAKC,QAAS,CAC/C,EAAKD,KAAKC,SAAU,EACpB,IAAMY,EAAY,EAAKpB,OAAOqB,UAAUC,IAClCC,EAAY,EAAKvB,OAAOqB,UAAUG,IACxC,EAAKxB,OAAOyB,KAAKL,GAAWG,GAAWG,WACvC,EAAK1B,OAAOqB,UAAUC,IAAM,EAAKA,IACjC,EAAKtB,OAAOqB,UAAUG,IAAM,EAAKA,IACjC,EAAKL,SAAS,CAAEX,SAAS,SACpB,GAAI,EAAKR,OAAOW,UAAY,EAAKJ,KAAKE,MAAO,CAClD,EAAKF,KAAKE,OAAQ,EAClB,IAAMW,EAAY,EAAKpB,OAAO2B,QAAQL,IAChCC,EAAY,EAAKvB,OAAO2B,QAAQH,IACtC,EAAKxB,OAAOyB,KAAKL,GAAWG,GAAWG,WACvC,EAAK1B,OAAO2B,QAAQL,IAAM,EAAKA,IAC/B,EAAKtB,OAAO2B,QAAQH,IAAM,EAAKA,IAC/B,EAAKL,SAAS,CAAEV,OAAO,IAGrB,EAAKT,OAAOE,aACd,EAAK0B,WApFM,EAkHnBC,SAAW,WACT,EAAKtB,KAAO,EAAKP,OAAOyB,KAAK,EAAKH,KAAK,EAAKE,KACxC,EAAKjB,KAAKuB,OACZ,EAAKX,SAAS,CAAEW,QAAQ,IACf,EAAKvB,KAAKwB,WACnB,EAAKZ,SAAS,CAAEY,WAAW,KAvHZ,EA6HnBC,gBAAkB,WAChB,EAAKb,SAAS,CAAEY,WAAW,KA9HV,EAiInBE,aAAe,WACb,EAAKd,SAAS,CAAEW,QAAQ,KAlIP,EAqInBI,QAAU,WACR,EAAK3B,KAAO,EAAKP,OAAOyB,KAAK,EAAKH,KAAK,EAAKE,KAC5C,EAAKL,SAAS,CACZW,QAAQ,EACRC,WAAW,EACXI,WAAW,EACXpB,OAAQ,EAAKR,KAAKQ,OAClBH,OAAQ,EAAKL,KAAKK,UA5IH,EAgJnBwB,WAAa,WACX,EAAKjB,SAAS,CAAEX,SAAS,EAAOC,OAAO,KA9IvC,EAAKT,OAAS,EAAKH,MAAMG,OACzB,EAAKsB,IAAM,EAAKzB,MAAMyB,IACtB,EAAKE,IAAM,EAAK3B,MAAM2B,IACtB,EAAKjB,KAAO,EAAKP,OAAOyB,KAAK,EAAKH,KAAK,EAAKE,KAC5C,EAAKI,OAAS,EAAK5B,OAAO4B,OAE1B,EAAKS,MAAQ,CACXtB,QAAQ,EACRH,OAAQ,EACRJ,QAAS,EAAKD,KAAKC,QACnBC,MAAO,EAAKF,KAAKE,MACjB0B,WAAW,EACXJ,WAAW,EACXD,QAAQ,GAhBO,E,iFAqJjB,IAAMQ,EAAY,QAAUC,KAAKjB,IAAM,IAAMiB,KAAKf,IAClDgB,SAASC,iBAAiB,SAAUF,KAAKV,UACzCW,SAASC,iBAAiB,QAASF,KAAKL,SACxCM,SAASC,iBAAiBH,EAAY,WAAYC,KAAKP,iBACvDQ,SAASC,iBAAiBH,EAAY,QAASC,KAAKN,cACpDO,SAASC,iBAAiBH,EAAY,MAAOC,KAAKH,c,+BAE1C,IAAD,EACuDG,KAAKF,MAA3D7B,EADD,EACCA,QAASC,EADV,EACUA,MAAOM,EADjB,EACiBA,OAAQgB,EADzB,EACyBA,UAAWD,EADpC,EACoCA,OAEvCY,EAAa,QAajB,OAZAA,GAAclC,EACV,aACAC,EACA,WACAM,EACA,YACAe,EACA,YACAC,EACA,eACA,GACJW,GAfO,EAC4C9B,OAc5B,EAAI,eAAiB,GAE1C,yBACE+B,UAAWD,EACX5C,YAAayC,KAAKzC,YAClBoB,aAAcqB,KAAKrB,cAEnB,6BAEE,uBAAGyB,UAAU,2BACb,uBAAGA,UAAU,0BACb,uBAAGA,UAAU,wC,GAvLWC,aCDbC,E,YACnB,WAAYhD,GAAQ,IAAD,8BACjB,4CAAMA,KAiBRiD,gBAAkB,WACZ,EAAKT,MAAMU,OACb,EAAK5B,SAAS,CAAE4B,QAAQ,IAExB,EAAK5B,SAAS,CAAE4B,QAAQ,KAtBT,EA6BnBC,kBAAoB,SAAAC,GAClB,EAAK9B,SAAS,CAAE+B,KAAMD,EAASF,QAAQ,IACvC,EAAKI,aAAaF,IA5BlB,EAAKG,QAAU,EAAKvD,MAAMuD,QAE1B,EAAKC,SAAW,EAAKxD,MAAMwD,SAE3B,EAAKF,aAAe,EAAKtD,MAAMsD,aAE/B,EAAKG,GAAK,EAAKzD,MAAMyD,GAErB,EAAKjB,MAAQ,CACXU,QAAQ,EACRG,KAAM,EAAKrD,MAAMqD,MAbF,E,sEAqCT,IAAD,OACDK,EACJ,qBAAuBhB,KAAKF,MAAMU,OAAS,UAAY,IACzD,OACE,yBAAKJ,UAAU,qBAAqBW,GAAIf,KAAKe,IAC3C,yBAAKX,UAAU,uBAAuBa,QAASjB,KAAKO,iBACjDP,KAAKc,UAER,yBAAKV,UAAU,cACb,yBAAKA,UAAU,qBAAqBa,QAASjB,KAAKO,iBAC/CP,KAAKF,MAAMa,MAEd,yBAAKP,UAAWY,GACbhB,KAAKa,QAAQK,KAAI,SAACP,EAAMQ,GACvB,OACE,yBACEf,UAAU,SACVgB,IAAKT,EACLM,QAAS,kBAAM,EAAKR,kBAAkBE,KAEtC,2BACEU,KAAK,QACLjB,UAAU,QACVW,GAAI,EAAKA,GAAK,SAAWI,EACzBR,KAAK,aAEP,2BAAOW,QAAS,EAAKP,GAAK,SAAWI,GAAQR,c,GAhE7BN,aCW5BkB,EAAY,SAAAZ,GAChB,IAAMa,EAAQ,IAAIC,YAAYd,GAC9BV,SAASyB,cAAcF,IAGJG,E,YAEnB,WAAYrE,GAAQ,IAAD,8BACjB,4CAAMA,KAoCRsE,SAAW,WACT,IAAK,IAAI7C,EAAM,EAAGA,EAjDH,GAiDqBA,IAAO,CACzC,EAAKG,KAAKH,GAAO,GACjB,IAAK,IAAIE,EAAM,EAAGA,EAlDL,GAkDuBA,IAClC,EAAKC,KAAKH,GAAKE,GAAO,IAAI4C,EAAW9C,EAAKE,GACtCF,IAAQ,EAAKD,UAAUC,KAAOE,IAAQ,EAAKH,UAAUG,MACvD,EAAKC,KAAKH,GAAKE,GAAKhB,SAAU,GAE5Bc,IAAQ,EAAKK,QAAQL,KAAOE,IAAQ,EAAKG,QAAQH,MACnD,EAAKC,KAAKH,GAAKE,GAAKf,OAAQ,KA9CjB,EAyDnBN,MAAQ,WAAoB,IAAnBkE,IAAkB,yDACzB,EAAKpE,SAAWqE,KAAKC,SACrB,EAAK9C,KAAK+C,SAAQ,SAAAlD,GAAG,OAAIA,EAAIkD,SAAQ,SAAAjE,GAAI,OAAIA,EAAKJ,cAC9CkE,GACFP,EAAU,UA7DK,EAkEnBW,MAAQ,WAAoB,IAAnBJ,IAAkB,yDACzB,EAAKpE,SAAWqE,KAAKC,SACrB,EAAK9C,KAAK+C,SAAQ,SAAAlD,GAAG,OAAIA,EAAIkD,SAAQ,SAAAjE,GAAI,OAAIA,EAAKkE,cAClD,EAAKtE,MAAMkE,IArEM,EAwEnBK,uBAAyB,WACvB,EAAK9C,QAAO,IAzEK,EA+EnBA,OAAS,WAAwB,IAAvB+C,EAAsB,wDAC9B,GAAuB,MAAnB,EAAKC,WAAoB,CAE3B,EAAKzE,QACL,IAAMkB,EAAY,EAAKI,KAAK,EAAKJ,UAAUC,KAAK,EAAKD,UAAUG,KAE/DH,EAAUwD,SAAW,EAEjB,EAAKD,aAAe,EAAKE,MAAM,IACjC,EAAKC,SACH1D,EACA,EAAKM,QAAQL,IACb,EAAKK,QAAQH,KACb,EACA,EAAKvB,SACL0E,GAGA,EAAKC,aAAe,EAAKE,MAAM,IACjC,EAAKC,SACH1D,EACA,EAAKM,QAAQL,IACb,EAAKK,QAAQH,KACb,EACA,EAAKvB,SACL0E,GAICA,GACHb,EAAU,cAEP,CAEL,IAAMkB,EAAUxC,SAASyC,eAAe,aACxCD,EAAQE,UAAUC,IAAI,eACtBC,YAAW,WACTJ,EAAQE,UAAUG,OAAO,iBACxB,OArHY,EA0HnBC,cAAgB,WACd,EAAKrE,UAAW,EAChB,EAAKD,aAAc,EACnB,EAAKF,YAAa,EAClB,EAAKD,eAAgB,EACrB,EAAKP,cAAe,EACpB,EAAKI,WAAY,EACjB,EAAKC,SAAU,EACf,EAAKN,cAAe,EAEhB,EAAKH,aACP,EAAK0B,UArIU,EAyInB2D,iBAAmB,SAAAtC,GACjB,EAAK2B,WAAa3B,GA1ID,EA8InBuC,oBAAsB,SAAAvC,GAElB,EAAK/C,YADS,OAAZ+C,GA/Ia,EAsJnBwC,kBAAoB,SAAAxC,GAEhB,EAAKyC,MADS,SAAZzC,EACW,GACQ,WAAZA,EACI,GAEA,IA5JE,EAiKnB0C,qBAAuB,WACrB,EAAKlB,OAAM,GAEX,EAAKhD,KAAK+C,SAAQ,SAAAlD,GAAG,OACnBA,EAAIkD,SAAQ,SAAAjE,GACLA,EAAKC,SAAYD,EAAKE,QACzBF,EAAKQ,QAAS,SAKpB,EAAK6E,cAAc,EAAKnE,KAAK,GAAG,IAEhC,EAAKtB,SA3KL,EAAKc,UAAW,EAChB,EAAKD,aAAc,EACnB,EAAKF,YAAa,EAClB,EAAKD,eAAgB,EACrB,EAAKP,cAAe,EACpB,EAAKD,cAAe,EACpB,EAAKK,WAAY,EACjB,EAAKC,SAAU,EACf,EAAKV,cAAW4F,EAChB,EAAKjB,WAAa,KAClB,EAAKkB,UAAW,EAChB,EAAKhB,MAAQ,CAAC,WAAY,MAC1B,EAAKiB,OAAS,CAAC,OAAQ,SAAU,QACjC,EAAKL,MAAQ,GACb,EAAKM,QAAU,CAAC,KAAM,OACtB,EAAK9F,aAAc,EACnB,EAAKyB,QAAU,CACbL,IAAK,GACLE,IAAK,IAEP,EAAKH,UAAY,CACfC,IAAK,GACLE,IAAK,GAEP,EAAKC,KAAO,GA3BK,E,iFAgCjBe,SAASyC,eAAe,QAAQxC,iBAAiB,eAAe,SAAA1C,GAC9DA,EAAEkG,sB,+BAgJI,IAAD,OAEP,OADA1D,KAAK4B,WAEH,yBAAKxB,UAAU,QACb,yBAAKA,UAAU,WACb,yBAAKA,UAAU,SACb,0CAEF,yBAAKA,UAAU,wBACb,kBAAC,EAAD,CACEQ,aAAcZ,KAAKgD,iBACnBrC,KAAK,mBACLE,QAASb,KAAKuC,MACdxB,GAAG,YACHD,SAAS,gBAEX,yBAAKV,UAAU,SAASa,QAASjB,KAAKmC,wBAAtC,aAGA,yBAAK/B,UAAU,SAASa,QAASjB,KAAKpC,OAAtC,cAGA,yBAAKwC,UAAU,SAASa,QAASjB,KAAKkC,OAAtC,yBAIA,kBAAC,EAAD,CACEtB,aAAcZ,KAAKiD,oBACnBtC,KAAMX,KAAKyD,QAAQ,GACnB5C,QAASb,KAAKyD,QACd1C,GAAG,eACHD,SAAS,mBAEX,kBAAC,EAAD,CACEF,aAAcZ,KAAKkD,kBACnBvC,KAAMX,KAAKwD,OAAO,GAClB3C,QAASb,KAAKwD,OACdzC,GAAG,aACHD,SAAS,YAEX,yBAAKV,UAAU,SAASa,QAASjB,KAAKoD,sBAAtC,mBAKJ,yBAAKrC,GAAG,WACN,yBAAKX,UAAU,qBACb,qDACA,yBAAKA,UAAU,kBAEjB,yBAAKA,UAAU,qBACb,0CACA,yBAAKA,UAAU,4BAGjB,yBAAKA,UAAU,qBACb,6CACA,yBAAKA,UAAU,+BAEjB,yBAAKA,UAAU,qBACb,0CACA,yBAAKA,UAAU,4BAEjB,yBAAKA,UAAU,qBACb,iEACA,yBAAKA,UAAU,4BACb,6BACE,uBAAGA,UAAU,sCAKrB,yBAAKW,GAAG,OAAOX,UAAU,WAAWuD,UAAW3D,KAAK+C,eACjD/C,KAAKd,KAAKgC,KAAI,SAAAnC,GAAG,OAChBA,EAAImC,KAAI,SAAAlD,GACN,OACE,kBAAC,EAAD,CACE+C,GAAI,OAAS/C,EAAKe,IAAM,IAAMf,EAAKiB,IACnCmC,IAAKpD,EAAKe,IAAM,IAAMf,EAAKiB,IAC3BF,IAAKf,EAAKe,IACVE,IAAKjB,EAAKiB,IACVxB,OAAQ,c,+BAmBtBmG,EACAC,EACAC,EACAC,EACAC,GAIC,IAAD,OAHA5B,EAGA,wDAFA6B,EAEA,uDAFY,GACZC,EACA,uDADY,EAGNC,EAAU,CACd,CAAEpF,IAAK,EAAGE,IAAK,GACf,CAAEF,KAAM,EAAGE,IAAK,GAChB,CAAEF,IAAK,EAAGE,IAAK,GACf,CAAEF,IAAK,EAAGE,KAAM,IAGde,KAAKuD,UACPY,EAAQC,KACN,CAAErF,IAAK,EAAGE,IAAK,GACf,CAAEF,KAAM,EAAGE,IAAK,GAChB,CAAEF,KAAM,EAAGE,KAAM,GACjB,CAAEF,IAAK,EAAGE,KAAM,IAIpB,IAAMoF,EAAY,kBAChBJ,EAAUK,MAAK,SAACC,EAAGC,GACjB,GAAIT,EAAO,CAET,IAAMU,EACJF,EAAEjC,SAAWiC,EAAEG,WAAaF,EAAElC,SAAWkC,EAAEE,WAE7C,OAAoB,IAAhBD,EACKA,EAGFF,EAAEG,UAAYF,EAAEE,UAGvB,OAAOH,EAAEjC,SAAWkC,EAAElC,aAItBqC,EAAgB,SAAC5F,EAAKE,GAE1B,GAAIF,EA9US,IA8UWA,GAAO,GAAKE,EA7UvB,IA6U2CA,GAAO,EAAG,CAEhE,IAAM2F,EAAgB,EAAK1F,KAAKH,GAAKE,GAErC,GACE2F,EAAcpG,QACdoG,EAAchF,WACdgF,EAAc3G,QAEd,OAAO,OAIsBqF,IAA3BsB,EAActC,UAChB2B,EAAUG,KAAKQ,IAKfA,EAAcvG,OAASuF,EAAWtB,SAAWsC,EAActC,eAChCgB,IAA3BsB,EAActC,YAEdsC,EAActC,SAAWsC,EAAcvG,OAASuF,EAAWtB,SAC3DsC,EAAchB,WAAaA,GAGzBG,QAAqCT,IAA5BsB,EAAcF,YAQzBE,EAAcF,UACZ3C,KAAK8C,IAAI5F,EAAM6E,GAAW/B,KAAK8C,IAAI9F,EAAM8E,IAUxCe,EAAcpF,YAEjBoF,EAAcpF,WAAY,EAEtB4C,GACFS,YAAW,WACL,EAAKnF,WAAasG,GACpBY,EAAcE,kBAKfZ,EAAY,EAAKf,UAQtB4B,EAAc,SAAdA,EAAetH,EAAQuH,GAEtBvH,EAAOQ,UACNmE,EACFS,YAAW,WACL,EAAKnF,WAAasG,GACpBvG,EAAOwH,gBAEPD,EAASvH,EAAO6E,UAAY,EAAKa,OAErC1F,EAAO8B,QAAS,EAElBwF,EAAYtH,EAAOmG,WAAYoB,KAInCb,EAAQlC,SAAQ,SAAAiD,GACdP,EAAcf,EAAW7E,IAAMmG,EAAOnG,IAAK6E,EAAW3E,IAAMiG,EAAOjG,QAGrEoF,IAEA,IAAMc,EAAWlB,EAAU,GAE3B,YAAiBX,IAAb6B,IAIJlB,EAAUmB,QAEVD,EAASvF,WAAY,EACjBuF,EAASjH,OAEX6G,EAAYI,EAAUjB,IACf,GAGFlE,KAAKwC,SACV2C,EACAtB,EACAC,EACAC,EACAC,EACA5B,EACA6B,EACAC,EAAY,M,oCAKFN,GAAa,IAAD,OAExBA,EAAWpE,WAAY,EACvBoE,EAAWpF,QAAS,EAEpB,IAMM6G,EAAsB,GAuB5B,GA7BgB,CACd,CAAEtG,IAAK,EAAGE,IAAK,GACf,CAAEF,KAAM,EAAGE,IAAK,GAChB,CAAEF,IAAK,EAAGE,IAAK,GACf,CAAEF,IAAK,EAAGE,KAAM,IAqBVgD,SAAQ,SAAAiD,IAjBM,SAACnG,EAAKE,GAC1B,GAAIF,EA/cS,IA+cWA,GAAO,GAAKE,EA9cvB,IA8c2CA,GAAO,EAAG,CAEhE,IAAM2F,EAAgB,EAAK1F,KAAKH,GAAKE,GAChC2F,EAAcpF,WAEjB6F,EAAoBjB,KAAKQ,IAY7BU,CAAc1B,EAAW7E,IAAMmG,EAAOnG,IAAK6E,EAAW3E,IAAMiG,EAAOjG,SAGhEoG,EAAoBE,OACvB,OAAO,EAGT,IAAMC,EAAkBzD,KAAK0D,MAC3B1D,KAAKC,SAAWqD,EAAoBE,QAGhCJ,EAAWE,EAAoBG,GAOrC,OANAL,EAAS1H,OAASmG,EAnBK,SAAA5F,GACrB,IAAMe,GAAOf,EAAKe,IAAM6E,EAAW7E,KAAO,EACpCE,GAAOjB,EAAKiB,IAAM2E,EAAW3E,KAAO,EAC1C,EAAKC,KAAKH,GAAKE,GAAKT,QAAS,EAkB/BkH,CAAeP,GAEfnF,KAAKqD,cAAc8B,GAEZnF,KAAKqD,cAAcO,O,GAzeIvD,aAgf5BwB,E,WACJ,WAAY9C,EAAKE,GAAM,oBAErBe,KAAKjB,IAAMA,EACXiB,KAAKf,IAAMA,EACXe,KAAK/B,SAAU,EACf+B,KAAK9B,OAAQ,EACb8B,KAAKxB,QAAS,EACdwB,KAAKR,WAAY,EACjBQ,KAAKT,QAAS,EACdS,KAAK3B,OAAS,EACd2B,KAAKsC,cAAWgB,EAChBtD,KAAK0E,eAAYpB,E,oDAIjBtD,KAAKJ,WAAY,EACjBI,KAAKR,WAAY,EACjBQ,KAAKT,QAAS,EACdS,KAAKsC,cAAWgB,EAChBtD,KAAK0E,eAAYpB,I,sCAIjB,IAAMvD,EAAY,QAAUC,KAAKjB,IAAM,IAAMiB,KAAKf,IAAM,WACxDsC,EAAUxB,K,mCAIVC,KAAKT,QAAS,EACd,IAAMQ,EAAY,QAAUC,KAAKjB,IAAM,IAAMiB,KAAKf,IAAM,QACxDsC,EAAUxB,K,iCAIVC,KAAK/B,SAAU,EACf+B,KAAK9B,OAAQ,EACb,IAAM6B,EAAY,QAAUC,KAAKjB,IAAM,IAAMiB,KAAKf,IAAM,MACxDsC,EAAUxB,K,8BAIVC,KAAKxB,QAAS,EACdwB,KAAK3B,OAAS,M,KCniBHsH,MANf,WACE,OACE,kBAAC,EAAD,OCIgBC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASjG,SAASyC,eAAe,SD6H3C,kBAAmByD,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.412fe35d.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\n//weight const\r\nconst WEIGHT = 15;\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    //in input it take the parent element and its row/col\r\n    this.parent = this.props.parent;\r\n    this.row = this.props.row;\r\n    this.col = this.props.col;\r\n    this.node = this.parent.grid[this.row][this.col];\r\n    this.launch = this.parent.launch;\r\n    //the state initialisation\r\n    this.state = {\r\n      isWall: false,\r\n      weight: 1,\r\n      isStart: this.node.isStart,\r\n      isEnd: this.node.isEnd,\r\n      isChecked: false,\r\n      isVisited: false,\r\n      isPath: false\r\n    };\r\n  }\r\n  //this handle the mouse down, i define what action is goin to be made when the mouse will enter other nodes\r\n  //if the actual node is a wall we say that we want to remove walls\r\n  //if its empty and we right click we want to add weight\r\n  //if its the start node we want to move it\r\n  //you got the point\r\n  onMouseDown = e => {\r\n    this.parent.launchID = null;\r\n    if (!this.parent.autoRefresh) {\r\n      this.parent.reset();\r\n    }\r\n    //if the button == 2 that mean its a right click\r\n    //wich mean the user want to add/remove weights\r\n    if (e.button === 2) {\r\n      this.parent.weightToggle = true;\r\n    }\r\n    this.parent.mousePressed = true;\r\n    if (this.node.isStart || this.node.isEnd) {\r\n      if (this.node.isStart) {\r\n        this.parent.moveStart = true;\r\n      } else {\r\n        this.parent.moveEnd = true;\r\n      }\r\n    } else {\r\n      if (this.parent.weightToggle) {\r\n        if (this.node.weight > 1) {\r\n          this.parent.removeWeights = true;\r\n        } else {\r\n          this.parent.addWeights = true;\r\n        }\r\n      } else {\r\n        if (this.node.isWall) {\r\n          this.parent.removeWalls = true;\r\n        } else {\r\n          this.parent.addWalls = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    //and we call the mouseEnter handler because the click event happend after the enter event\r\n    this.onMouseEnter();\r\n  };\r\n  //here we do thing based on what has been defined by the mouseDown handler\r\n  onMouseEnter = () => {\r\n    if (this.parent.mousePressed) {\r\n      if ((this.parent.moveStart || this.parent.moveEnd) && !this.node.isWall) {\r\n        //if we want to move the start/end node we set the actual one to true and update the ex one\r\n        if (this.parent.moveStart && !this.node.isStart) {\r\n          this.node.isStart = true;\r\n          const exNodeRow = this.parent.startNode.row;\r\n          const exNodeCol = this.parent.startNode.col;\r\n          this.parent.grid[exNodeRow][exNodeCol].updateIO();\r\n          this.parent.startNode.row = this.row;\r\n          this.parent.startNode.col = this.col;\r\n          this.setState({ isStart: true });\r\n        } else if (this.parent.moveEnd && !this.node.isEnd) {\r\n          this.node.isEnd = true;\r\n          const exNodeRow = this.parent.endNode.row;\r\n          const exNodeCol = this.parent.endNode.col;\r\n          this.parent.grid[exNodeRow][exNodeCol].updateIO();\r\n          this.parent.endNode.row = this.row;\r\n          this.parent.endNode.col = this.col;\r\n          this.setState({ isEnd: true });\r\n        }\r\n        //if the autoRefrsh is on we refresh the path\r\n        if (this.parent.autoRefresh) {\r\n          this.launch();\r\n        }\r\n      } else {\r\n        //here i if we want to add/remove walls/weights\r\n        if (\r\n          this.parent.addWalls &&\r\n          !this.node.isWall &&\r\n          this.node.weight === 1\r\n        ) {\r\n          this.node.isWall = true;\r\n          this.setState({ isWall: true });\r\n        } else if (this.parent.removeWalls && this.node.isWall) {\r\n          this.node.isWall = false;\r\n          this.setState({ isWall: false });\r\n        } else if (\r\n          this.parent.addWeights &&\r\n          this.node.weight === 1 &&\r\n          !this.node.isWall\r\n        ) {\r\n          this.node.weight = WEIGHT;\r\n          this.setState({ weight: WEIGHT });\r\n        } else if (this.parent.removeWeights && this.node.weight > 1) {\r\n          this.node.weight = 1;\r\n          this.setState({ weight: 1 });\r\n        }\r\n      }\r\n    }\r\n  };\r\n  //this is the handler for when the update event is send\r\n  //it just change the visited/path state\r\n  onUpdate = () => {\r\n    this.node = this.parent.grid[this.row][this.col];\r\n    if (this.node.isPath) {\r\n      this.setState({ isPath: true });\r\n    } else if (this.node.isVisited) {\r\n      this.setState({ isVisited: true });\r\n    }\r\n  };\r\n  //this is the handlers for the animations update,\r\n  //the animation is based on timeout that send event to the node\r\n  //this one update the visited state\r\n  onVisitedUpdate = () => {\r\n    this.setState({ isVisited: true });\r\n  };\r\n  //and this one the path state\r\n  onPathUpdate = () => {\r\n    this.setState({ isPath: true });\r\n  };\r\n  //this is the reset event handler\r\n  onReset = () => {\r\n    this.node = this.parent.grid[this.row][this.col];\r\n    this.setState({\r\n      isPath: false,\r\n      isVisited: false,\r\n      isChecked: false,\r\n      isWall: this.node.isWall,\r\n      weight: this.node.weight\r\n    });\r\n  };\r\n  //this handle the reset io event, it update to false end/start state\r\n  onIOUpdate = () => {\r\n    this.setState({ isStart: false, isEnd: false });\r\n  };\r\n  //when the component has been rendered we add its event listener\r\n  componentDidMount() {\r\n    const eventName = \"node-\" + this.row + \"-\" + this.col;\r\n    document.addEventListener(\"update\", this.onUpdate);\r\n    document.addEventListener(\"reset\", this.onReset);\r\n    document.addEventListener(eventName + \"-visited\", this.onVisitedUpdate);\r\n    document.addEventListener(eventName + \"-path\", this.onPathUpdate);\r\n    document.addEventListener(eventName + \"-IO\", this.onIOUpdate);\r\n  }\r\n  render() {\r\n    const { isStart, isEnd, isWall, isVisited, isPath, weight } = this.state;\r\n    //we just update the class of the div based onthe state\r\n    let classNames = \"node \";\r\n    classNames += isStart\r\n      ? \"node-start\"\r\n      : isEnd\r\n      ? \"node-end\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isPath\r\n      ? \"node-path\"\r\n      : isVisited\r\n      ? \"node-visited\"\r\n      : \"\";\r\n    classNames += weight > 1 ? \" node-weight\" : \"\";\r\n    return (\r\n      <div\r\n        className={classNames}\r\n        onMouseDown={this.onMouseDown}\r\n        onMouseEnter={this.onMouseEnter}\r\n      >\r\n        <div>\r\n          {/* these are the start/end/weight icons wich will be render or not by the css based on the class */}\r\n          <i className=\"far fa-dot-circle iend\"></i>\r\n          <i className=\"far fa-compass istart\"></i>\r\n          <i className=\"fas fa-weight-hanging iweight\"></i>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\n\r\n//here is the component to the droping list selector\r\n//its the one who i need the most to rework the HTML/CSS\r\nexport default class List extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    //in input it take an array of choices\r\n    this.choices = this.props.choices;\r\n    //and a \"question\", which is just the \"algorithm :\" in front of the drop list\r\n    this.question = this.props.question;\r\n    //a function from its parent wich need the choice in input and will do stuff with it\r\n    this.handleChange = this.props.handleChange;\r\n    //and an ID\r\n    this.id = this.props.id;\r\n    //and the state need 2 things, if its active an the name of the selection\r\n    this.state = {\r\n      active: false,\r\n      name: this.props.name\r\n    };\r\n  }\r\n  //thats when you click on the list\r\n  //it just change toggle the state.active\r\n  handleListClick = () => {\r\n    if (this.state.active) {\r\n      this.setState({ active: false });\r\n    } else {\r\n      this.setState({ active: true });\r\n    }\r\n  };\r\n  //and thats the handler for when you choose an option\r\n  //it change the selection (I dont know why i called it name but whatever, might change that in the future)\r\n  //and close the options\r\n  //and passe the selected item to the change handler\r\n  handleOptionClick = content => {\r\n    this.setState({ name: content, active: false });\r\n    this.handleChange(content);\r\n  };\r\n  //Yeah CSS is a bitch I cant figure out how you center text vertically, so its not centered and it looks like crap\r\n  //I know I do something very weird here and the css that goes along is crappy as hell\r\n  //but it slapt that shit together just to have something to look at, I will change that in the future\r\n  //(thats one of the benefit of React, the component way)\r\n  render() {\r\n    const optionsContainerClass =\r\n      \"options-container\" + (this.state.active ? \" active\" : \"\");\r\n    return (\r\n      <div className=\"drop-list noselect\" id={this.id}>\r\n        <div className=\"list-question button\" onClick={this.handleListClick}>\r\n          {this.question}\r\n        </div>\r\n        <div className=\"select-box\">\r\n          <div className=\"list-button button\" onClick={this.handleListClick}>\r\n            {this.state.name}\r\n          </div>\r\n          <div className={optionsContainerClass}>\r\n            {this.choices.map((name, index) => {\r\n              return (\r\n                <div\r\n                  className=\"option\"\r\n                  key={name}\r\n                  onClick={() => this.handleOptionClick(name)}\r\n                >\r\n                  <input\r\n                    type=\"radio\"\r\n                    className=\"radio\"\r\n                    id={this.id + \"option\" + index}\r\n                    name=\"category\"\r\n                  />\r\n                  <label htmlFor={this.id + \"option\" + index}>{name}</label>\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node\";\r\nimport List from \"./List\";\r\n\r\n//ok this component is a fucking mess but i will try my best to explain it\r\n//all the comments for dijkstra,A* and the maze generator are purely implementation oriented,\r\n//if you want to really understand the code look about those algorithms online,\r\n//I learned Dijkstra and A* with computerphile videos\r\n//and the maze generation general idea with this video : https://www.youtube.com/watch?v=elMXlO28Q1U\r\n\r\n//const declaration\r\nconst ROW_NUMBER = 23; //23\r\nconst COL_NUMBER = 51; //51\r\n//and an event trigger, which will just trigger every event listener that listen for the event name that you pass to the function\r\n//(this app is heavily based on event, i couldnt found another way to centralised the nodes but to update there state themself)\r\nconst sendEvent = name => {\r\n  const event = new CustomEvent(name);\r\n  document.dispatchEvent(event);\r\n};\r\n\r\nexport default class Grid extends Component {\r\n  //this component has no input\r\n  constructor(props) {\r\n    super(props);\r\n    //variable declaration\r\n    this.addWalls = false;\r\n    this.removeWalls = false;\r\n    this.addWeights = false;\r\n    this.removeWeights = false;\r\n    this.mousePressed = false;\r\n    this.weightToggle = false;\r\n    this.moveStart = false;\r\n    this.moveEnd = false;\r\n    this.launchID = undefined;\r\n    this.activeAlgo = null;\r\n    this.diagonal = false; //not implemented yet\r\n    this.algos = [\"Dijkstra\", \"A*\"];\r\n    this.speeds = [\"Fast\", \"Normal\", \"Slow\"];\r\n    this.speed = 20;\r\n    this.refresh = [\"ON\", \"OFF\"];\r\n    this.autoRefresh = true;\r\n    this.endNode = {\r\n      row: 11,\r\n      col: 45\r\n    };\r\n    this.startNode = {\r\n      row: 11,\r\n      col: 5\r\n    };\r\n    this.grid = [];\r\n  }\r\n  //when the component is rendered, we prevent the right click pop up, I know its a bad things to do\r\n  //but its just that if every time you add a weight you have this pop up its annoying\r\n  componentDidMount() {\r\n    document.getElementById(\"grid\").addEventListener(\"contextmenu\", e => {\r\n      e.preventDefault();\r\n    });\r\n  }\r\n  //this is to create the grid, wich is just an array of array of nodes (declaration of the class at the end)\r\n  initGrid = () => {\r\n    for (let row = 0; row < ROW_NUMBER; row++) {\r\n      this.grid[row] = [];\r\n      for (let col = 0; col < COL_NUMBER; col++) {\r\n        this.grid[row][col] = new createNode(row, col);\r\n        if (row === this.startNode.row && col === this.startNode.col) {\r\n          this.grid[row][col].isStart = true;\r\n        }\r\n        if (row === this.endNode.row && col === this.endNode.col) {\r\n          this.grid[row][col].isEnd = true;\r\n        }\r\n      }\r\n    }\r\n  };\r\n  //this is to reset all the nodes\r\n  //we also reset the launchID\r\n  //and we tell the nodes they have been reset by triggering the event\r\n  //the difference of reset vs clear is that reset is path related (visited nodes and path)\r\n  // and clear is obstacle related (walls and weight)\r\n  //the update input is in cas we want to reset them but not update them visualy\r\n  reset = (update = true) => {\r\n    this.launchID = Math.random();\r\n    this.grid.forEach(row => row.forEach(node => node.reset()));\r\n    if (update) {\r\n      sendEvent(\"reset\");\r\n    }\r\n  };\r\n  //this is to clear all the nodes\r\n  //and we also call reset at the end\r\n  clear = (update = true) => {\r\n    this.launchID = Math.random();\r\n    this.grid.forEach(row => row.forEach(node => node.clear()));\r\n    this.reset(update);\r\n  };\r\n  //this is to handle the visualize button click\r\n  visualizeButtonHandler = () => {\r\n    this.launch(true);\r\n  };\r\n  //this is the function that launch the algorithm\r\n  //its input is if we have the animtion or not\r\n  //if you click visualize you have the animation\r\n  //but if you move the start node around you dont want to have the animation\r\n  launch = (animation = false) => {\r\n    if (this.activeAlgo != null) {\r\n      //first we reset all the nodes\r\n      this.reset();\r\n      const startNode = this.grid[this.startNode.row][this.startNode.col];\r\n      //then we initialize the start node distance\r\n      startNode.distance = 0;\r\n      //then we look wich algo is active and fire it up\r\n      if (this.activeAlgo === this.algos[0]) {\r\n        this.Dijkstra(\r\n          startNode,\r\n          this.endNode.row,\r\n          this.endNode.col,\r\n          false,\r\n          this.launchID,\r\n          animation\r\n        );\r\n      }\r\n      if (this.activeAlgo === this.algos[1]) {\r\n        this.Dijkstra(\r\n          startNode,\r\n          this.endNode.row,\r\n          this.endNode.col,\r\n          true,\r\n          this.launchID,\r\n          animation\r\n        );\r\n      }\r\n      //then if there is no animation we just told the nodes to update themself\r\n      if (!animation) {\r\n        sendEvent(\"update\");\r\n      }\r\n    } else {\r\n      //if there is no algorithm choosen we just do a little animation on the select button\r\n      const element = document.getElementById(\"algo-list\");\r\n      element.classList.add(\"choose-algo\");\r\n      setTimeout(() => {\r\n        element.classList.remove(\"choose-algo\");\r\n      }, 200);\r\n    }\r\n  };\r\n  //the nodes component handle the moue down/enter themself, but we handle the mouseUp here\r\n  //we just rest all the variable related to create/delete/move things around\r\n  handleMouseUp = () => {\r\n    this.addWalls = false;\r\n    this.removeWalls = false;\r\n    this.addWeights = false;\r\n    this.removeWeights = false;\r\n    this.mousePressed = false;\r\n    this.moveStart = false;\r\n    this.moveEnd = false;\r\n    this.weightToggle = false;\r\n    //and if the auto refresh is toggle we update the path\r\n    if (this.autoRefresh) {\r\n      this.launch();\r\n    }\r\n  };\r\n  //change the active variable based on woch one has been choosen in the list\r\n  handleAlgoChange = content => {\r\n    this.activeAlgo = content;\r\n  };\r\n\r\n  //toggle the auto refresh\r\n  handleRefreshChange = content => {\r\n    if (content === \"ON\") {\r\n      this.autoRefresh = true;\r\n    } else {\r\n      this.autoRefresh = false;\r\n    }\r\n  };\r\n  //change the speed animation based on the choice made\r\n  handleSpeedChange = content => {\r\n    if (content === \"Slow\") {\r\n      this.speed = 40;\r\n    } else if (content === \"Normal\") {\r\n      this.speed = 20;\r\n    } else {\r\n      this.speed = 10;\r\n    }\r\n  };\r\n  //this launch the maze generation\r\n  //we reset all the nodes but don't update them(cause we reset them after)\r\n  handleMazeGeneration = () => {\r\n    this.clear(false);\r\n    //we make each node a wall, exept the end/start nodes\r\n    this.grid.forEach(row =>\r\n      row.forEach(node => {\r\n        if (!node.isStart && !node.isEnd) {\r\n          node.isWall = true;\r\n        }\r\n      })\r\n    );\r\n    //and then we call the maze generator who will just cut its way through the walls\r\n    this.mazeGenerator(this.grid[1][1]);\r\n    //then we reset the node again because we modified the isVisited properties of most of them\r\n    this.reset();\r\n  };\r\n\r\n  render() {\r\n    this.initGrid();\r\n    return (\r\n      <div className=\"main\">\r\n        <nav className=\"nav-bar\">\r\n          <div className=\"title\">\r\n            <p>PathFinder</p>\r\n          </div>\r\n          <div className=\"options-bar noselect\">\r\n            <List\r\n              handleChange={this.handleAlgoChange}\r\n              name=\"Select Algorithm\"\r\n              choices={this.algos}\r\n              id=\"algo-list\"\r\n              question=\"Algorithm :\"\r\n            />\r\n            <div className=\"button\" onClick={this.visualizeButtonHandler}>\r\n              Visualize\r\n            </div>\r\n            <div className=\"button\" onClick={this.reset}>\r\n              Clear Path\r\n            </div>\r\n            <div className=\"button\" onClick={this.clear}>\r\n              Clear Walls & Weights\r\n            </div>\r\n\r\n            <List\r\n              handleChange={this.handleRefreshChange}\r\n              name={this.refresh[0]}\r\n              choices={this.refresh}\r\n              id=\"refresh-list\"\r\n              question=\"Auto Refresh :\"\r\n            />\r\n            <List\r\n              handleChange={this.handleSpeedChange}\r\n              name={this.speeds[1]}\r\n              choices={this.speeds}\r\n              id=\"speed-list\"\r\n              question=\"Speed :\"\r\n            />\r\n            <div className=\"button\" onClick={this.handleMazeGeneration}>\r\n              Generate Maze\r\n            </div>\r\n          </div>\r\n        </nav>\r\n        <div id=\"exemple\">\r\n          <div className=\"exemple-container\">\r\n            <p>Unvisited/Blank Node :</p>\r\n            <div className=\"node exemple\"></div>\r\n          </div>\r\n          <div className=\"exemple-container\">\r\n            <p>Wall Node :</p>\r\n            <div className=\"node exemple node-wall\"></div>\r\n          </div>\r\n\r\n          <div className=\"exemple-container\">\r\n            <p>Visited Node :</p>\r\n            <div className=\"node exemple node-visited\"></div>\r\n          </div>\r\n          <div className=\"exemple-container\">\r\n            <p>Path Node :</p>\r\n            <div className=\"node exemple node-path\"></div>\r\n          </div>\r\n          <div className=\"exemple-container\">\r\n            <p>Weighted Node (cost 15 to cross) :</p>\r\n            <div className=\"node exemple node-weight\">\r\n              <div>\r\n                <i className=\"fas fa-weight-hanging iweight\"></i>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div id=\"grid\" className=\"noselect\" onMouseUp={this.handleMouseUp}>\r\n          {this.grid.map(row =>\r\n            row.map(node => {\r\n              return (\r\n                <Node\r\n                  id={\"node\" + node.row + \"-\" + node.col}\r\n                  key={node.row + \"-\" + node.col}\r\n                  row={node.row}\r\n                  col={node.col}\r\n                  parent={this}\r\n                />\r\n              );\r\n            })\r\n          )}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n  //big oof\r\n  //so here is my implementation of dijkstra\r\n  //Im sure its can be optimised but meh\r\n  //so in input: the start node, the goal row/col, if we use A* or not,the launchID and if we enable animation\r\n  //so first the launchID, what the heck is that? well if the animation is still going throught and then boum you want a maze\r\n  //you will have your maze but the setTimeout are goig to say: 'I dont care, my mission is to make you a visited node'\r\n  //so to prevent that before each launch of the algorithm i create a random launchID\r\n  //so in the setTimeout I look if the ID has changed, if yes, it dont do shit and my maze is fine\r\n  //so to stop the animation to occur I just change one variable\r\n  Dijkstra(\r\n    parentNode,\r\n    goalRow,\r\n    goalCol,\r\n    astar,\r\n    ID,\r\n    animation = false,\r\n    nodeQueue = [],\r\n    iteration = 0\r\n  ) {\r\n    //here are the vectors for looking at the neighbours\r\n    const vectors = [\r\n      { row: 1, col: 0 },\r\n      { row: -1, col: 0 },\r\n      { row: 0, col: 1 },\r\n      { row: 0, col: -1 }\r\n    ];\r\n    // NOT IMPLEMENTED YET\r\n    if (this.diagonal) {\r\n      vectors.push(\r\n        { row: 1, col: 1 },\r\n        { row: -1, col: 1 },\r\n        { row: -1, col: -1 },\r\n        { row: 1, col: -1 }\r\n      );\r\n    }\r\n    //the function to call to sort the queue\r\n    const sortQueue = () =>\r\n      nodeQueue.sort((a, b) => {\r\n        if (astar) {\r\n          //if we use A* we sort by the distance to the origins + the heurisric distance\r\n          const comparaison =\r\n            a.distance + a.heuristic - (b.distance + b.heuristic);\r\n          //if the comparaison decide which of the 2 elements is the better we return it\r\n          if (comparaison !== 0) {\r\n            return comparaison;\r\n          }\r\n          //otherwise compare the heuristic value of the 2 elements\r\n          return a.heuristic - b.heuristic;\r\n        } else {\r\n          // with vanilla Dijkstra we sort by the distance to the origin\r\n          return a.distance - b.distance;\r\n        }\r\n      });\r\n    //the function that check the neigbours of the active nodes\r\n    const testNeighbour = (row, col) => {\r\n      //if its off limit we dont try it\r\n      if (row < ROW_NUMBER && row >= 0 && col < COL_NUMBER && col >= 0) {\r\n        //we retrieve the node\r\n        const neighbourNode = this.grid[row][col];\r\n        //if its a wall,the origin or the node checked, we dont need to try so we end the function\r\n        if (\r\n          neighbourNode.isWall ||\r\n          neighbourNode.isChecked ||\r\n          neighbourNode.isStart\r\n        ) {\r\n          return false; // the return is just to end the function, we dont need to return false\r\n        }\r\n        //to simplify the algorithms I consider undefined as infinity\r\n        //so if its the first time we visit the node we add it to the queue\r\n        if (neighbourNode.distance === undefined) {\r\n          nodeQueue.push(neighbourNode);\r\n        }\r\n        //if it has an infinite distance or if the weight + the 'parent' node distance is less than its actual distance\r\n        //we update its distance and its parent\r\n        if (\r\n          neighbourNode.weight + parentNode.distance < neighbourNode.distance ||\r\n          neighbourNode.distance === undefined\r\n        ) {\r\n          neighbourNode.distance = neighbourNode.weight + parentNode.distance;\r\n          neighbourNode.parentNode = parentNode;\r\n        }\r\n        //if we use A* we assign a heuristic value to the node\r\n        if (astar && neighbourNode.heuristic === undefined) {\r\n          //I propose 2 ways to compute this heuristic value,\r\n          //I didnt made any research on wich one is the best for this case (a grid)\r\n          // but i found the first one to look better with the animations turned on\r\n          //the fisrt on is the min amount of node you ould have to cross if there is no wall or weighted nodes\r\n          //the second one is pure euclidian distance\r\n          //feel free to uncomment/comment those line and try by yourself\r\n          // 1\r\n          neighbourNode.heuristic =\r\n            Math.abs(col - goalCol) + Math.abs(row - goalRow);\r\n          // 2\r\n          // neighbourNode.heuristic = Math.sqrt(\r\n          //   (row - goalRow) ** 2 + (col - goalCol) ** 2\r\n          // );\r\n        }\r\n        // if we are doing some time comparaison we can desactivate the visual update,\r\n        // who will just prevent nodes to refresh their class attributes\r\n        //this if statement is purely visual, so we can skip it\r\n\r\n        if (!neighbourNode.isVisited) {\r\n          //if it was never visited before we set it to true\r\n          neighbourNode.isVisited = true;\r\n          //if we have animation on, we set a timeout to update the node\r\n          if (animation) {\r\n            setTimeout(() => {\r\n              if (this.launchID === ID) {\r\n                neighbourNode.updateVisited();\r\n              }\r\n              //this commented line is because I used to set the timeout based on the distance to the origin\r\n              //but to really show how the algorithm work i based it on when she has been visited\r\n              // }, neighbourNode.distance * this.speed);\r\n            }, iteration * this.speed);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    //here is the function to call to update visually the path\r\n    //the offset is the amount of time the visited animation take\r\n    //beause we want to update the path after\r\n    const pathFounded = (parent, offset) => {\r\n      //we skip the start node\r\n      if (!parent.isStart) {\r\n        if (animation) {\r\n          setTimeout(() => {\r\n            if (this.launchID === ID) {\r\n              parent.updatePath();\r\n            }\r\n          }, (offset + parent.distance) * this.speed);\r\n        } else {\r\n          parent.isPath = true;\r\n        }\r\n        pathFounded(parent.parentNode, offset);\r\n      }\r\n    };\r\n    //here we just cycle through each vector to check the neighbours of the current active node\r\n    vectors.forEach(vector => {\r\n      testNeighbour(parentNode.row + vector.row, parentNode.col + vector.col);\r\n    });\r\n    //then we sort the queue\r\n    sortQueue();\r\n    //and get the next 'parent' node\r\n    const nextNode = nodeQueue[0];\r\n    //if nextNode is undefined, that mean that every possible path as been explore but the end has never been reached, so there is no path to the end node\r\n    if (nextNode === undefined) {\r\n      return false;\r\n    }\r\n    //we remove it from the queue\r\n    nodeQueue.shift();\r\n    //and mark it as checked so we will never look at it again\r\n    nextNode.isChecked = true;\r\n    if (nextNode.isEnd) {\r\n      // pathFounded(nextNode, nextNode.distance);\r\n      pathFounded(nextNode, iteration);\r\n      return true;\r\n    }\r\n    //and we call dijktra again and pass it the new Active Node, the Queue and increment the iteration count\r\n    return this.Dijkstra(\r\n      nextNode,\r\n      goalRow,\r\n      goalCol,\r\n      astar,\r\n      ID,\r\n      animation,\r\n      nodeQueue,\r\n      iteration + 1\r\n    );\r\n  }\r\n  //this maze generator is  just a recursive backtracking\r\n  //we give him an active node\r\n  mazeGenerator(parentNode) {\r\n    //it set it to visited and remove the walls on it\r\n    parentNode.isVisited = true;\r\n    parentNode.isWall = false;\r\n    //its the same vectors than the path finding algorithms but with an scale of 2\r\n    const vectors = [\r\n      { row: 2, col: 0 },\r\n      { row: -2, col: 0 },\r\n      { row: 0, col: 2 },\r\n      { row: 0, col: -2 }\r\n    ];\r\n    const availablesNeigbours = [];\r\n    //thi function will test the giver neigbours\r\n    const testNeigbours = (row, col) => {\r\n      if (row < ROW_NUMBER && row >= 0 && col < COL_NUMBER && col >= 0) {\r\n        //we skip it if its out of bound or if its already been visited\r\n        const neighbourNode = this.grid[row][col];\r\n        if (!neighbourNode.isVisited) {\r\n          //then we add it to the neigbours queue\r\n          availablesNeigbours.push(neighbourNode);\r\n        }\r\n      }\r\n    };\r\n    //this is to remove the walls between this node and the next node\r\n    const openMiddleNode = node => {\r\n      const row = (node.row + parentNode.row) / 2;\r\n      const col = (node.col + parentNode.col) / 2;\r\n      this.grid[row][col].isWall = false;\r\n    };\r\n    //we test all our neigbours node\r\n    vectors.forEach(vector => {\r\n      testNeigbours(parentNode.row + vector.row, parentNode.col + vector.col);\r\n    });\r\n    //if there is no available neighbours we stop for this node\r\n    if (!availablesNeigbours.length) {\r\n      return false;\r\n    }\r\n    //we want a random number between 0 and the number of neigbours we have - 1\r\n    const randomNeighbour = Math.floor(\r\n      Math.random() * availablesNeigbours.length\r\n    );\r\n    //we now have our random neibour\r\n    const nextNode = availablesNeigbours[randomNeighbour];\r\n    nextNode.parent = parentNode;\r\n    //we remove the wall between them\r\n    openMiddleNode(nextNode);\r\n    //and call the function on it\r\n    this.mazeGenerator(nextNode);\r\n    //when the recursion of the nextnode end the current node might still have neigbours, so we call the function again on itself\r\n    return this.mazeGenerator(parentNode);\r\n    //and thats it\r\n  }\r\n}\r\n\r\n//node class declaration\r\n\r\nclass createNode {\r\n  constructor(row, col) {\r\n    //variable init\r\n    this.row = row;\r\n    this.col = col;\r\n    this.isStart = false;\r\n    this.isEnd = false;\r\n    this.isWall = false;\r\n    this.isVisited = false;\r\n    this.isPath = false;\r\n    this.weight = 1;\r\n    this.distance = undefined;\r\n    this.heuristic = undefined;\r\n  }\r\n  //call to reset path related things\r\n  reset() {\r\n    this.isChecked = false;\r\n    this.isVisited = false;\r\n    this.isPath = false;\r\n    this.distance = undefined;\r\n    this.heuristic = undefined;\r\n  }\r\n  //update the visited state of its corresponding node component\r\n  updateVisited() {\r\n    const eventName = \"node-\" + this.row + \"-\" + this.col + \"-visited\";\r\n    sendEvent(eventName);\r\n  }\r\n  //update the path state of its corresponding node component\r\n  updatePath() {\r\n    this.isPath = true;\r\n    const eventName = \"node-\" + this.row + \"-\" + this.col + \"-path\";\r\n    sendEvent(eventName);\r\n  }\r\n  //reset the end/start state of its corresponding node\r\n  updateIO() {\r\n    this.isStart = false;\r\n    this.isEnd = false;\r\n    const eventName = \"node-\" + this.row + \"-\" + this.col + \"-IO\";\r\n    sendEvent(eventName);\r\n  }\r\n  //clear wall and weight\r\n  clear() {\r\n    this.isWall = false;\r\n    this.weight = 1;\r\n  }\r\n}\r\n","import React from 'react';\n// import logo from './logo.svg';\nimport './App.css';\nimport './css/main.css'\nimport Grid from \"./components/Grid\"\n\nfunction App() {\n  return (\n    <Grid />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}